name: gitops-argocd-dryrun

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  dryrun:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Pinpoint & show any bad scaffold artifacts (like a bare " line)
      - name: Sanity — no stray scaffold artifacts
        run: |
          set -euo pipefail
          echo "Scanning for stray scaffold artifacts…"

          FAIL=0

          echo ">> Checking for literal \"\$@\" lines"
          if HITS=$(grep -R -n -E '^[[:space:]]*"\$@"[[:space:]]*$' \
            --binary-files=without-match \
            --exclude-dir=.git --exclude-dir=_argo_apps \
            --include='*.tf' --include='*.tfvars' --include='*.yml' --include='*.yaml' \
            . || true); then
            if [ -n "$HITS" ]; then
              echo "::error::Found stray '\"$@\"' line(s):"
              echo "$HITS"
              FAIL=1
            fi
          fi

          echo ">> Checking for bare double-quote lines"
          if HITS=$(grep -R -n -E '^[[:space:]]*"[[:space:]]*$' \
            --binary-files=without-match \
            --exclude-dir=.git --exclude-dir=_argo_apps \
            --exclude='*.tar' --exclude='*.bin' --exclude='*.binary' \
            --include='*.tf' --include='*.tfvars' --include='*.yml' --include='*.yaml' \
            . || true); then
            if [ -n "$HITS" ]; then
              echo "::group::Bare double-quote offenders (with context)"
              echo "$HITS"
              # show 3 lines of context for each hit
              echo "$HITS" | cut -d: -f1-2 | while IFS=: read -r f l; do
                echo "---- $f:$l ----"
                nl -ba "$f" | sed -n "$((l-3)),$((l+3))p" || true
              done
              echo "::endgroup::"
              FAIL=1
            fi
          fi

          if [ "$FAIL" -eq 1 ]; then
            echo "::error::Please remove the lines above and re-run."
            exit 1
          fi

          echo "OK: No stray scaffold artifacts."

      # Create a default tfvars for this scenario if missing
      - name: Ensure tfvars/gitops.tfvars exists
        run: |
          set -euo pipefail
          mkdir -p tfvars
          if [ ! -f tfvars/gitops.tfvars ]; then
            : > tfvars/gitops.tfvars
            echo 'project       = "gitops-argocd"'        >> tfvars/gitops.tfvars
            echo 'environment   = "dryrun"'               >> tfvars/gitops.tfvars
            echo 'name_prefix   = "gitops"'               >> tfvars/gitops.tfvars
            echo 'repo_url      = "https://github.com/your-org/your-repo.git"' >> tfvars/gitops.tfvars
            echo 'chart_path    = "helm/app"'             >> tfvars/gitops.tfvars
            echo 'enable_gitops = true'                   >> tfvars/gitops.tfvars
            echo "Created tfvars/gitops.tfvars"
          else
            echo "tfvars/gitops.tfvars already present"
          fi

      - name: Install jq & yq
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Set up Terraform (1.6.6)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform fmt & validate
        run: |
          terraform -chdir=terraform init -backend=false
          terraform -chdir=terraform fmt -recursive
          terraform -chdir=terraform validate

      - name: Terraform plan (plan-only, zero cost)
        run: |
          set -euo pipefail
          terraform -chdir=terraform init -backend=false
          terraform -chdir=terraform plan -refresh=false \
            -var-file=../tfvars/gitops.tfvars \
            -out=tfplan.binary
          terraform -chdir=terraform show tfplan.binary | sed -n '1,160p'
          terraform -chdir=terraform show -json tfplan.binary > tfplan.json

      # Gate: enforce Argo CD Applications have automated prune/selfHeal + CreateNamespace=true
      # (Parse Application YAML from local_file resources inside the plan; no cluster/API calls)
      - name: Gate — Argo CD Applications must enable automated prune/selfHeal and CreateNamespace
  run: |
    set -euo pipefail

    mkdir -p _argo_apps

    # Extract Argo CD Application YAMLs from local_file resources (no cluster calls)
    while IFS=$'\t' read -r FILENAME CONTENT; do
      if printf '%s\n' "$CONTENT" | grep -q '^kind: *Application' && \
         printf '%s\n' "$CONTENT" | grep -q '^apiVersion: *argoproj.io/'; then
        BASENAME="$(basename "$FILENAME")"
        OUT="_argo_apps/${BASENAME}"
        printf '%s\n' "$CONTENT" > "$OUT"
      fi
    done < <(
      jq -r '
        .resource_changes[]?
        | select(.type=="local_file")
        | .change.after as $after
        | [$after.filename, $after.content]
        | @tsv
      ' tfplan.json
    )

    COUNT=$(find _argo_apps -maxdepth 1 -type f -name '*.yaml' | wc -l | tr -d ' ')
    if [ "${COUNT:-0}" -lt 1 ]; then
      echo "::error::No Argo CD Applications found in plan (via local_file outputs)."
      echo "Tip: Ensure terraform/main.tf renders Applications using local_file + yamlencode."
      exit 1
    fi

    BAD=""
    for f in _argo_apps/*.yaml; do
      [ -e "$f" ] || break
      j="$(yq -o=json '.' "$f")"
      name="$(printf '%s' "$j" | jq -r '.metadata.name')"
      prune="$(printf '%s' "$j" | jq -r '.spec.syncPolicy.automated.prune // false')"
      selfHeal="$(printf '%s' "$j" | jq -r '.spec.syncPolicy.automated.selfHeal // false')"
      hasCreateNs="$(printf '%s' "$j" | jq -r '
        (.spec.syncPolicy.syncOptions // [])
        | map(tostring)
        | any(. == "CreateNamespace=true")
      ')"
      if [ "$prune" != "true" ] || [ "$selfHeal" != "true" ] || [ "$hasCreateNs" != "true" ]; then
        opts="$(printf '%s' "$j" | jq -r '(.spec.syncPolicy.syncOptions // []) | join(",")')"
        BAD="${BAD}\n${name}: prune=${prune} selfHeal=${selfHeal} opts=[${opts}]"
      fi
    done

    if [ -n "${BAD//\\n/}" ]; then
      echo "::error::Applications missing required GitOps settings:${BAD}"
      exit 1
    fi

    echo "OK: All Applications have automated {prune,selfHeal} and CreateNamespace=true."

      - name: Plan summary
        run: |
          set -euo pipefail
          ADDS=$(jq '[.resource_changes[]? | select(.change.actions|index("create"))] | length' tfplan.json)
          TYPES=$(jq -r '
            [.resource_changes[]? | select(.change.actions|index("create")) | .type]
            | group_by(.) | map({type: .[0], count: length})
            | sort_by(-.count)
            | (["Type","Creates"] as $H | $H), (.[] | [.type, (.count|tostring)])
            | @tsv' tfplan.json | column -t)
          {
            echo "# GitOps ArgoCD Dry-Run Plan Summary"
            echo
            echo "**Adds:** ${ADDS}"
            echo
            echo "## Created Resource Types"
            echo '```text'
            echo "$TYPES"
            echo '```'
          } > plan-summary.md
          sed -n '1,120p' plan-summary.md
          {
            echo "### GitOps Dry-Run Summary"
            echo
            echo "- Adds: ${ADDS}"
            echo "- Gate: ArgoCD Applications have prune/selfHeal + CreateNamespace=true"
            echo
            echo "_Artifacts: tfplan.binary, tfplan.json, plan-summary.md, _argo_apps/*_"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: gitops-argocd-dryrun-artifacts
          path: |
            tfplan.json
            terraform/tfplan.binary
            plan-summary.md
            _argo_apps
          if-no-files-found: error
